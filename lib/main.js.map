{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n\n# { atomic\n#   bound\n#   capture\n#   charSet\n#   either\n#   flags\n#   lookAhead\n#   lookBehind\n#   maybe\n#   namedCapture\n#   noBound\n#   notAhead\n#   notBehind\n#   ref\n#   sequence\n#   suffix                } = require 'compose-regexp-commonjs'\nXXX_CRX = require 'compose-regexp-commonjs'\n#-----------------------------------------------------------------------------------------------------------\nXXX_unicode = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true, } else flags.add 'u', x\nXXX_sticky  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,  } else flags.add 'y', x\nXXX_dotall  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,  } else flags.add 's', x\nXXX_dotAll  = XXX_dotall\n\n\n\n#===========================================================================================================\nclass Interlex\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    throw new Error \"^interlex@1^ cfg not implemented\" if cfg?\n    @reset()\n    @base_mode    = null\n    @registry     = {}\n    @_metachr     = '𝔛' # used for identifying group keys\n    @_metachrlen  = @_metachr.length\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexeme: ( mode, name, pattern ) ->\n    help '^31-1^', \"#{mode}:#{name}\", GUY.trm.white pattern\n    @base_mode   ?= mode\n    lexemes       = ( @registry[ mode ] ?= { lexemes: [], } ).lexemes\n    lexemes.push XXX_CRX.namedCapture ( @_metachr + name ), pattern\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  finalize: ->\n    for mode, entry of @registry\n      @registry[ mode ].pattern = XXX_sticky XXX_unicode XXX_dotall XXX_CRX.either entry.lexemes...\n      debug '^45-1^', @registry[ mode ].pattern\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset: ->\n    @state                             ?= {}\n    @state.stack                        = []\n    @state.mode                         = @base_mode\n    @state.prv_last_idx                 = 0\n    @registry[ mode ].pattern.lastIndex = 0 for mode, entry of @registry\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _token_from_match: ( prv_last_idx, match, mode = null ) ->\n    x = null\n    R = { mode, }\n    for key, value of match.groups\n      continue unless value?\n      if key.startsWith @_metachr\n        R.key     = key[ @_metachrlen .. ]\n        R.mk      = if mode? then \"#{mode}:#{R.key}\" else R.key\n        R.value   = value\n      else\n        ( x ?= {} )[ key ]  = if value is '' then null else value\n    R.start = prv_last_idx\n    R.stop  = prv_last_idx + match[ 0 ].length\n    R.x     = x\n    return R\n\n\n#===========================================================================================================\nmodule.exports = { Interlex, }\n\n"
  ]
}