{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n{ misfit\n  jump_symbol\n  get_base_types }        = require './types'\n#...........................................................................................................\n_CRX  = require 'compose-regexp-commonjs'\n_X    =\n  unicode:    ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true,   } else flags.add 'u', x\n  sticky:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,    } else flags.add 'y', x\n  dotall:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,    } else flags.add 's', x\n  multiline:  ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { multiline: true, } else flags.add 'm', x\n_X.dotAll = _X.dotall\ncompose   = C = { _CRX..., _X..., }\n\n#===========================================================================================================\nclass Interlex\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @types        = get_base_types()\n    @cfg          = Object.freeze @types.create.ilx_constructor_cfg cfg\n    @start()\n    @base_mode    = null\n    @registry     = {}\n    @_metachr     = '𝔛' # used for identifying group keys\n    @_metachrlen  = @_metachr.length\n    @jump_symbol  = jump_symbol\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexeme: ( cfg ) ->\n    cfg                       = @types.create.ilx_add_lexeme_cfg cfg\n    @state.finalized          = false\n    @base_mode               ?= cfg.mode\n    ### TAINT use API ###\n    entry                     = @registry[ cfg.mode ] ?= { lexemes: {}, pattern: null, }\n    entry.lexemes[ cfg.tid ]  = lexeme = { cfg..., }\n    lexeme.pattern            = if @types.isa.regex lexeme.pattern then @_rename_groups lexeme.tid, lexeme.pattern\n    lexeme.pattern            = C.namedCapture ( @_metachr + cfg.tid ), lexeme.pattern\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _rename_groups: ( name, re ) ->\n    source = re.source.replace /(?:(?<=\\\\\\\\)|(?<!\\\\))\\(\\?<([^>]+)>/gu, \"(?<#{name}#{@_metachr}$1>\"\n    return new RegExp source, re.flags\n\n  #---------------------------------------------------------------------------------------------------------\n  _finalize: ->\n    return unless @state?\n    for mode, entry of @registry\n      ### TAINT use API ###\n      patterns                  = ( lexeme.pattern for tid, lexeme of entry.lexemes )\n      pattern                   = C.either patterns...\n      ### TAINT could / should set all flags in single step ###\n      pattern                   = C.dotall    pattern if @cfg.dotall\n      pattern                   = C.multiline pattern if @cfg.multiline\n      @registry[ mode ].pattern = C.sticky C.unicode pattern\n    for mode, entry of @registry\n      for tid, lexeme of entry.lexemes\n        continue unless lexeme.jump?\n        continue if lexeme.jump is jump_symbol\n        continue if @registry[ lexeme.jump ]?\n        throw new Error \"^interlex._finalize@1^ unknown jump target in lexeme #{rpr lexeme}\"\n    @state.finalized = true\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  start: ( source = null ) ->\n    @types.validate.optional.text source\n    return @_start source\n\n  #---------------------------------------------------------------------------------------------------------\n  _start: ( source = null ) ->\n    ### TAINT use `@types.create.ilx_state()` ###\n    @_finalize() if @state? and not @state.finalized\n    @state                             ?= {}\n    @state.finalized                   ?= false\n    @state.stack                        = []\n    @state.prv_last_idx                 = 0\n    @state.mode                         = @base_mode ? null\n    @state.pattern                      = @registry?[ @state.mode ]?.pattern ? null\n    @state.source                       = source\n    @state.finished                     = false\n    @registry[ mode ].pattern.lastIndex = 0 for mode, entry of @registry\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  feed: ( source ) ->\n    @types.validate.text source\n    return @_start source if @cfg.autostart\n    @state.source = source\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  rpr_token: ( token ) ->\n    # @types.validate.ilx_token token\n    t = token\n    j = token.jump\n    R = []\n    R.push t.mk + if j? then ( if j is jump_symbol then j else \">#{j}\") else ''\n    R.push \"(#{t.start}:#{t.stop})\"\n    R.push \"=#{rpr t.value}\"\n    R.push \"#{k}:#{rpr v}\" for k, v of t.x ? {}\n    return \"[#{R.join ','}]\"\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_token: ( tid, value, length, x = null, lexeme = null ) ->\n    start = @state.prv_last_idx\n    stop  = start + length\n    jump  = lexeme?.jump ? null\n    ### TAINT use `types.create.ilx_token {}` ###\n    return { mode: @state.mode, tid, mk: \"#{@state.mode}:#{tid}\", jump, value, start, stop, x, }\n\n  #---------------------------------------------------------------------------------------------------------\n  _token_and_lexeme_from_match: ( match ) ->\n    x = null\n    for key, value of match.groups\n      continue unless value?\n      if key.startsWith @_metachr\n        token_tid           = key[ @_metachrlen .. ]\n        token_value         = value\n      else\n        key                 = ( key.split @_metachr )[ 1 ]\n        ( x ?= {} )[ key ]  = if value is '' then null else value\n    lexeme  = @registry[ @state.mode ].lexemes[ token_tid ]\n    token   = @_new_token token_tid, token_value, match[ 0 ].length, x, lexeme\n    return { token, lexeme, }\n\n  #---------------------------------------------------------------------------------------------------------\n  run: ( source ) -> [ ( @walk source )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source ) ->\n    @feed source\n    #.......................................................................................................\n    loop\n      break if @state.finished\n      yield Y if ( Y = @step() )?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  step: ->\n    if @state.prv_last_idx >= @state.source.length\n      ### reached end ###\n      @state.finished = true\n      return @_new_token '$eof', '', 0\n    match = @state.source.match @state.pattern\n    unless match?\n      ### TAINT might want to advance and try again? ###\n      @state.finished = true\n      return @_new_token '$error', '', 0, { code: 'nomatch', }\n    if @state.pattern.lastIndex is @state.prv_last_idx\n      if match?\n        { token } = @_token_and_lexeme_from_match match\n        ### TAINT uses code units, should use codepoints ###\n        center    = token.stop\n        left      = Math.max 0, center - 11\n        right     = Math.min @state.source.length, center + 11\n        before    = @state.source[ left ... center ]\n        after     = @state.source[ center + 1 .. right ]\n        mid       = @state.source[ center ]\n        ### TAINT raise error or return error token ###\n        warn '^31-9^', { before, mid, after, }\n        warn '^31-10^', GUY.trm.reverse \"pattern #{rpr token.tid} matched empty string; stopping\"\n        @state.finished = true\n      else\n        ### TAINT raise error or return error token ###\n        warn '^31-11^', GUY.trm.reverse \"nothing matched; detected loop, stopping\"\n        @state.finished = true\n        return null\n    #.....................................................................................................\n    { token\n      lexeme } = @_token_and_lexeme_from_match match\n    #.....................................................................................................\n    if      lexeme.jump is jump_symbol  then @_pop_mode()\n    else if lexeme.jump?                then @_push_mode lexeme\n    @state.prv_last_idx = @state.pattern.lastIndex\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  _pop_mode: ->\n    @state.mode               = @state.stack.pop()\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _push_mode: ( lexeme ) ->\n    @state.stack.push @state.mode\n    @state.mode               = lexeme.jump\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return null\n\n\n#===========================================================================================================\nmodule.exports = { Interlex, compose, }\n\n"
  ]
}