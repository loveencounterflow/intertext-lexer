{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "AAGA;EAAA;AAAA,MAAA,GAAA,EAAA,QAAA,EAAA,OAAA,EAAA,UAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,KAAA,EAAA,UAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAA,cAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,CAAA,CAAE,KAAF,EACE,KADF,EAEE,IAFF,EAGE,IAHF,EAIE,KAJF,EAKE,MALF,EAME,IANF,EAOE,IAPF,EAQE,OARF,CAAA,GAQ4B,GAAG,CAAC,GAAG,CAAC,WAAR,CAAoB,iBAApB,CAR5B;;EASA,CAAA,CAAE,GAAF,EACE,OADF,EAEE,IAFF,EAGE,GAHF,CAAA,GAG4B,GAAG,CAAC,GAHhC,EAdA;;;EAmBA,CAAA,CAAE,MAAF,EACE,UADF,CAAA,GAC4B,GAAG,CAAC,QADhC;;EAEA,CAAA,CAAE,cAAF,CAAA,GAA4B,OAAA,CAAQ,SAAR,CAA5B,EArBA;;;;;;;;;;;;;;;;;;EAuCA,OAAA,GAAU,OAAA,CAAQ,yBAAR,EAvCV;;;EAyCA,WAAA,GAAc,QAAA,CAAE,CAAF,CAAA;IAAS,IAAK,CAAA,YAAa,MAAlB;aAAgC,UAAA,CAAW,CAAX,EAAc;QAAE,OAAA,EAAS;MAAX,CAAd,EAAhC;KAAA,MAAA;aAAsE,KAAK,CAAC,GAAN,CAAU,GAAV,EAAe,CAAf,EAAtE;;EAAT;;EACd,UAAA,GAAc,QAAA,CAAE,CAAF,CAAA;IAAS,IAAK,CAAA,YAAa,MAAlB;aAAgC,UAAA,CAAW,CAAX,EAAc;QAAE,MAAA,EAAQ;MAAV,CAAd,EAAhC;KAAA,MAAA;aAAsE,KAAK,CAAC,GAAN,CAAU,GAAV,EAAe,CAAf,EAAtE;;EAAT;;EACd,UAAA,GAAc,QAAA,CAAE,CAAF,CAAA;IAAS,IAAK,CAAA,YAAa,MAAlB;aAAgC,UAAA,CAAW,CAAX,EAAc;QAAE,MAAA,EAAQ;MAAV,CAAd,EAAhC;KAAA,MAAA;aAAsE,KAAK,CAAC,GAAN,CAAU,GAAV,EAAe,CAAf,EAAtE;;EAAT;;EACd,UAAA,GAAc,WA5Cd;;;EAiDM,WAAN,MAAA,SAAA,CAAA;;IAGE,WAAa,CAAE,GAAF,CAAA;MACX,IAAsD,WAAtD;QAAA,MAAM,IAAI,KAAJ,CAAU,kCAAV,EAAN;OAAJ;;;;;;;MAOI,IAAC,CAAA,KAAD,GAAgB,cAAA,CAAA;MAChB,IAAC,CAAA,KAAD,CAAA;MACA,IAAC,CAAA,SAAD,GAAgB;MAChB,IAAC,CAAA,QAAD,GAAgB,CAAA;MAChB,IAAC,CAAA,QAAD,GAAgB,KAXpB;MAYI,IAAC,CAAA,WAAD,GAAgB,IAAC,CAAA,QAAQ,CAAC;AAC1B,aAAO;IAdI,CADf;;;IAkBE,UAAY,CAAE,IAAF,EAAQ,IAAR,EAAc,OAAd,CAAA;AACd,UAAA,IAAA,EAAA;;QAAI,IAAC,CAAA,YAAe;;MAChB,OAAA,GAAgB,4CAAW,CAAE,IAAF,QAAA,CAAE,IAAF,IAAY;QAAE,OAAA,EAAS;MAAX,CAAvB,CAAyC,CAAC;MAC1D,IAAiD,IAAC,CAAA,KAAK,CAAC,GAAG,CAAC,KAAX,CAAiB,OAAjB,CAAjD;QAAA,OAAA,GAAgB,IAAC,CAAA,cAAD,CAAgB,IAAhB,EAAsB,OAAtB,EAAhB;;MACA,OAAO,CAAC,IAAR,CAAa,OAAO,CAAC,YAAR,CAAuB,IAAC,CAAA,QAAD,GAAY,IAAnC,EAA2C,OAA3C,CAAb;AACA,aAAO;IALG,CAlBd;;;IA0BE,cAAgB,CAAE,IAAF,EAAQ,EAAR,CAAA;AAClB,UAAA;MAAI,MAAA,GAAS,EAAE,CAAC,MAAM,CAAC,OAAV,CAAkB,wBAAlB,EAA4C,CAAA,GAAA,CAAA,CAAM,IAAN,CAAA,CAAA,CAAa,IAAC,CAAA,QAAd,CAAA,GAAA,CAA5C;AACT,aAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,EAAE,CAAC,KAAtB;IAFO,CA1BlB;;;IA+BE,QAAU,CAAA,CAAA;AACZ,UAAA,KAAA,EAAA,IAAA,EAAA;AAAI;MAAA,KAAA,WAAA;;QACE,IAAC,CAAA,QAAQ,CAAE,IAAF,CAAQ,CAAC,OAAlB,GAA4B,UAAA,CAAW,WAAA,CAAY,UAAA,CAAW,OAAO,CAAC,MAAR,CAAe,GAAA,KAAK,CAAC,OAArB,CAAX,CAAZ,CAAX;MAD9B;AAEA,aAAO;IAHC,CA/BZ;;;IAqCE,KAAO,CAAA,CAAA;AACT,UAAA,KAAA,EAAA,IAAA,EAAA;;QAAI,IAAC,CAAA,QAAqC,CAAA;;MACtC,IAAC,CAAA,KAAK,CAAC,KAAP,GAAsC;MACtC,IAAC,CAAA,KAAK,CAAC,IAAP,GAAsC,IAAC,CAAA;MACvC,IAAC,CAAA,KAAK,CAAC,YAAP,GAAsC;AACtC;MAAA,KAAA,WAAA;;QAAA,IAAC,CAAA,QAAQ,CAAE,IAAF,CAAQ,CAAC,OAAO,CAAC,SAA1B,GAAsC;MAAtC;AACA,aAAO;IANF,CArCT;;;IA8CE,UAAY,CAAE,GAAF,EAAO,KAAP,EAAc,KAAd,EAAqB,IAArB,EAA2B,IAAI,IAA/B,CAAA;AACV,aAAO;QAAE,IAAA,EAAM,IAAC,CAAA,KAAK,CAAC,IAAf;QAAqB,GAArB;QAA0B,EAAA,EAAI,CAAA,CAAA,CAAG,IAAC,CAAA,KAAK,CAAC,IAAV,CAAA,CAAA,CAAA,CAAkB,GAAlB,CAAA,CAA9B;QAAuD,KAAvD;QAA8D,KAA9D;QAAqE,IAArE;QAA2E;MAA3E;IADG,CA9Cd;;;IAkDE,iBAAmB,CAAE,KAAF,CAAA;AACrB,UAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,SAAA,EAAA,WAAA,EAAA,KAAA,EAAA;MAAI,CAAA,GAAI;AACJ;MAAA,KAAA,UAAA;;QACE,IAAgB,aAAhB;AAAA,mBAAA;;QACA,IAAG,GAAG,CAAC,UAAJ,CAAe,IAAC,CAAA,QAAhB,CAAH;UACE,SAAA,GAAsB,GAAG;UACzB,WAAA,GAAsB,MAFxB;SAAA,MAAA;UAIE,GAAA,GAAsB,CAAE,GAAG,CAAC,KAAJ,CAAU,IAAC,CAAA,QAAX,CAAF,CAAuB,CAAE,CAAF;UAC7C,aAAE,IAAA,IAAK,CAAA,CAAP,CAAW,CAAE,GAAF,CAAX,GAAyB,KAAA,KAAS,EAAZ,GAAoB,IAApB,GAA8B,MALtD;;MAFF;MAQA,IAAA,GAAQ,IAAC,CAAA,KAAK,CAAC,YAAP,GAAsB,KAAK,CAAE,CAAF,CAAK,CAAC;AACzC,aAAO,IAAC,CAAA,UAAD,CAAY,SAAZ,EAAuB,WAAvB,EAAoC,IAAC,CAAA,KAAK,CAAC,YAA3C,EAAyD,IAAzD,EAA+D,CAA/D;IAXU,CAlDrB;;;IAgEE,GAAK,CAAE,MAAF,CAAA;aAAc,CAAE,GAAA,CAAE,IAAC,CAAA,IAAD,CAAM,MAAN,CAAF,CAAF;IAAd,CAhEP;;;IAmEQ,EAAN,IAAM,CAAE,MAAF,CAAA,EAAA;;AACR,UAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA,KAAA,EAAA,SAAA,EAAA,GAAA,EAAA,YAAA,EAAA,OAAA,EAAA,OAAA,EAAA,KAAA,EAAA;MAAI,IAAC,CAAA,KAAD,CAAA,EAAJ;MACI,OAAA,GAAY,IAAC,CAAA,QAAQ,CAAE,IAAC,CAAA,KAAK,CAAC,IAAT,CAAe,CAAC;MACrC,SAAA,GAAY,MAAM,CAAC,MAAP,GAAgB;AAE5B;aAAA,IAAA,GAAA;;QACE,IAAG,IAAC,CAAA,KAAK,CAAC,YAAP,GAAsB,SAAzB;;UAEE,MAAM,IAAC,CAAA,UAAD,CAAY,MAAZ,EAAoB,EAApB,EAAwB,SAAA,GAAY,CAApC,EAAuC,SAAA,GAAY,CAAnD;AACN,gBAHF;;QAIA,KAAA,GAAQ,MAAM,CAAC,KAAP,CAAa,OAAb;QACR,IAAO,aAAP;UACE,MAAM,IAAC,CAAA,UAAD,CAAY,QAAZ,EAAsB,EAAtB,EAA0B,IAAC,CAAA,KAAK,CAAC,YAAjC,EAA+C,IAAC,CAAA,KAAK,CAAC,YAAtD,EAAoE;YAAE,IAAA,EAAM;UAAR,CAApE;AACN,gBAFF;;QAGA,IAAG,OAAO,CAAC,SAAR,KAAqB,IAAC,CAAA,KAAK,CAAC,YAA/B;UACE,IAAG,aAAH;YACE,IAAA,CAAK,QAAL,EAAe,CAAE,GAAA,KAAK,CAAC,MAAR,CAAf;YACA,IAAA,CAAK,QAAL,EAAe,KAAA,GAAS,IAAC,CAAA,iBAAD,CAAmB,KAAnB,CAAxB;YAEA,MAAA,GAAS,KAAK,CAAC;YACf,IAAA,GAAS,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,MAAA,GAAS,EAArB;YACT,KAAA,GAAS,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,MAAhB,EAAwB,MAAA,GAAS,EAAjC;YACT,MAAA,GAAS,MAAM;YACf,KAAA,GAAS,MAAM;YACf,GAAA,GAAS,MAAM,CAAE,MAAF;YACf,IAAA,CAAK,QAAL,EAAe,CAAE,MAAF,EAAU,GAAV,EAAe,KAAf,CAAf;YACA,IAAA,CAAK,SAAL,EAAgB,GAAG,CAAC,GAAG,CAAC,OAAR,CAAgB,CAAA,QAAA,CAAA,CAAW,GAAA,CAAI,KAAK,CAAC,GAAV,CAAX,CAAA,+BAAA,CAAhB,CAAhB,EAXF;WAAA,MAAA;YAaE,IAAA,CAAK,SAAL,EAAgB,GAAG,CAAC,GAAG,CAAC,OAAR,CAAgB,0CAAhB,CAAhB,EAbF;;AAcA,gBAfF;SARN;;QAyBM,KAAA,GAAQ,IAAC,CAAA,iBAAD,CAAmB,KAAnB;QACR,MAAM,MA1BZ;;QA4BM,IAAG,KAAK,CAAC,GAAG,CAAC,UAAV,CAAqB,QAArB,CAAH;UACE,IAAC,CAAA,KAAK,CAAC,KAAK,CAAC,IAAb,CAAkB,IAAC,CAAA,KAAK,CAAC,IAAzB;UACA,IAAC,CAAA,KAAK,CAAC,IAAP,GAAoB,KAAK,CAAC,GAAG,CAAC,OAAV,CAAkB,QAAlB,EAA4B,EAA5B;UACpB,YAAA,GAAoB,OAAO,CAAC;UAC5B,OAAA,GAAoB,IAAC,CAAA,QAAQ,CAAE,IAAC,CAAA,KAAK,CAAC,IAAT,CAAe,CAAC;UAC7C,OAAO,CAAC,SAAR,GAAoB,aALtB;;SAAA,MAOK,IAAG,KAAK,CAAC,GAAN,KAAa,QAAhB;UACH,IAAC,CAAA,KAAK,CAAC,IAAP,GAAoB,IAAC,CAAA,KAAK,CAAC,KAAK,CAAC,GAAb,CAAA;UACpB,YAAA,GAAoB,OAAO,CAAC;UAC5B,OAAA,GAAoB,IAAC,CAAA,QAAQ,CAAE,IAAC,CAAA,KAAK,CAAC,IAAT,CAAe,CAAC;UAC7C,OAAO,CAAC,SAAR,GAAoB,aAJjB;SAnCX;;qBAyCM,IAAC,CAAA,KAAK,CAAC,YAAP,GAAsB,OAAO,CAAC;MA1ChC,CAAA;;IALI,CAnER;;;IAqHE,IAAM,CAAA,CAAA,EAAA;;EAvHR,EAjDA;;;EA4KA,MAAM,CAAC,OAAP,GAAiB,CAAE,QAAF;AA5KjB",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n{ get_base_types }        = require './types'\n\n# { atomic\n#   bound\n#   capture\n#   charSet\n#   either\n#   flags\n#   lookAhead\n#   lookBehind\n#   maybe\n#   namedCapture\n#   noBound\n#   notAhead\n#   notBehind\n#   ref\n#   sequence\n#   suffix                } = require 'compose-regexp-commonjs'\nXXX_CRX = require 'compose-regexp-commonjs'\n#-----------------------------------------------------------------------------------------------------------\nXXX_unicode = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true, } else flags.add 'u', x\nXXX_sticky  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,  } else flags.add 'y', x\nXXX_dotall  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,  } else flags.add 's', x\nXXX_dotAll  = XXX_dotall\n\n\n\n#===========================================================================================================\nclass Interlex\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    throw new Error \"^interlex@1^ cfg not implemented\" if cfg?\n    ###\n    cfg =\n      autoreset:    true\n      end_token:    true\n      error_tokens: true\n    ###\n    @types        = get_base_types()\n    @reset()\n    @base_mode    = null\n    @registry     = {}\n    @_metachr     = '𝔛' # used for identifying group keys\n    @_metachrlen  = @_metachr.length\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexeme: ( mode, name, pattern ) ->\n    @base_mode   ?= mode\n    lexemes       = ( @registry[ mode ] ?= { lexemes: [], } ).lexemes\n    pattern       = @_rename_groups name, pattern if @types.isa.regex pattern\n    lexemes.push XXX_CRX.namedCapture ( @_metachr + name ), pattern\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _rename_groups: ( name, re ) ->\n    source = re.source.replace /(?<!\\\\)\\(\\?<([^>]+)>/gu, \"(?<#{name}#{@_metachr}$1>\"\n    return new RegExp source, re.flags\n\n  #---------------------------------------------------------------------------------------------------------\n  finalize: ->\n    for mode, entry of @registry\n      @registry[ mode ].pattern = XXX_sticky XXX_unicode XXX_dotall XXX_CRX.either entry.lexemes...\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  reset: ->\n    @state                             ?= {}\n    @state.stack                        = []\n    @state.mode                         = @base_mode\n    @state.prv_last_idx                 = 0\n    @registry[ mode ].pattern.lastIndex = 0 for mode, entry of @registry\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_token: ( key, value, start, stop, x = null ) ->\n    return { mode: @state.mode, key, mk: \"#{@state.mode}:#{key}\", value, start, stop, x, }\n\n  #---------------------------------------------------------------------------------------------------------\n  _token_from_match: ( match ) ->\n    x = null\n    for key, value of match.groups\n      continue unless value?\n      if key.startsWith @_metachr\n        token_key           = key[ @_metachrlen .. ]\n        token_value         = value\n      else\n        key                 = ( key.split @_metachr )[ 1 ]\n        ( x ?= {} )[ key ]  = if value is '' then null else value\n    stop  = @state.prv_last_idx + match[ 0 ].length\n    return @_new_token token_key, token_value, @state.prv_last_idx, stop, x\n\n  #---------------------------------------------------------------------------------------------------------\n  run: ( source ) -> [ ( @walk source )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source ) ->\n    @reset() # if @cfg.autoreset\n    pattern   = @registry[ @state.mode ].pattern\n    max_index = source.length - 1\n    #.......................................................................................................\n    loop\n      if @state.prv_last_idx > max_index\n        ### reached end ###\n        yield @_new_token '$eof', '', max_index + 1, max_index + 1\n        break\n      match = source.match pattern\n      unless match?\n        yield @_new_token '$error', '', @state.prv_last_idx, @state.prv_last_idx, { code: 'nomatch', }\n        break\n      if pattern.lastIndex is @state.prv_last_idx\n        if match?\n          warn '^31-7^', { match.groups..., }\n          warn '^31-8^', token  = @_token_from_match match\n          ### TAINT uses code units, should use codepoints ###\n          center = token.stop\n          left   = Math.max 0, center - 11\n          right  = Math.min source.length, center + 11\n          before = source[ left ... center ]\n          after  = source[ center + 1 .. right ]\n          mid    = source[ center ]\n          warn '^31-9^', { before, mid, after, }\n          warn '^31-10^', GUY.trm.reverse \"pattern #{rpr token.key} matched empty string; stopping\"\n        else\n          warn '^31-11^', GUY.trm.reverse \"nothing matched; detected loop, stopping\"\n        break\n      #.....................................................................................................\n      token = @_token_from_match match\n      yield token\n      #.....................................................................................................\n      if token.key.startsWith 'gosub_'\n        @state.stack.push @state.mode\n        @state.mode       = token.key.replace 'gosub_', ''\n        old_last_idx      = pattern.lastIndex\n        pattern           = @registry[ @state.mode ].pattern\n        pattern.lastIndex = old_last_idx\n      #.....................................................................................................\n      else if token.key is 'return'\n        @state.mode       = @state.stack.pop()\n        old_last_idx      = pattern.lastIndex\n        pattern           = @registry[ @state.mode ].pattern\n        pattern.lastIndex = old_last_idx\n      #.....................................................................................................\n      @state.prv_last_idx = pattern.lastIndex\n\n  #---------------------------------------------------------------------------------------------------------\n  step: ->\n\n\n#===========================================================================================================\nmodule.exports = { Interlex, }\n\n"
  ]
}