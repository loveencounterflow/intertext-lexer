{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../../src/tools/outline-preprocessor.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERLEX/START-STOP-PREPROC'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n{ misfit\n  get_base_types }        = require '../types'\nlets                      = GUY.lft.lets\n\n\n#===========================================================================================================\nclass @Outline_preprocessor\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @types        = get_base_types()\n    @cfg          = Object.freeze @types.create.ilx_outline_preprocessor_cfg cfg\n    @_lexer       = @_new_prelexer()\n    @_parser      = @_new_preparser()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source_or_cfg ) -> @_parser.send source_or_cfg; yield from @_parser.walk()\n  run:  ( source_or_cfg ) -> [ ( @walk source_or_cfg )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_prelexer: ( cfg ) ->\n    { Interlex }  = require '../main'\n    lexer         = new Interlex { split: 'lines', cfg..., }\n    #.......................................................................................................\n    do =>\n      mode = 'outline'\n      create = ( token ) =>\n        token.data           ?= {}\n        token.data.indent    ?= ''\n        token.data.material  ?= ''\n        token.data.level      = token.data.indent.length / @cfg.indent_module\n        return token\n      ### NOTE consider to allow escaping newlines ###\n      # lexer.add_lexeme { mode, tid: 'escchr',         pattern: /\\\\(?<chr>.)/u,                      reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'blank',            pattern: /^\\s*$/u, }\n      lexer.add_lexeme { mode, tid: 'material', create, pattern: /^(?<indent>(?:\\x20\\x20)*)(?<material>.+)$/, }\n    #.......................................................................................................\n    return lexer\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_preparser: ->\n    { Pipeline\n      $         } = require 'moonriver'\n    p             = new Pipeline()\n    # #.......................................................................................................\n    # join = ( collector, joinerase ) =>\n    #   { joiner\n    #     eraser }  = joinerase\n    #   first_t     = collector.at 0\n    #   last_t      = collector.at -1\n    #   return lets first_t, ( d ) =>\n    #     #...................................................................................................\n    #     if joiner?\n    #       d.value = ( ( t.value for t in collector ).join joiner ).trimEnd()\n    #     else\n    #       parts     = []\n    #       last_idx  = collector.length - 1\n    #       for t, idx in collector\n    #         parts.push t.value\n    #         continue if idx >= last_idx\n    #         parts.push eraser.repeat distance if ( distance = collector[ idx + 1 ].x1 - t.x2 ) > 0\n    #       d.value = ( parts.join '' ).trimEnd()\n    #     #...................................................................................................\n    #     d.lnr1  = first_t.lnr1\n    #     d.x1    = first_t.x1\n    #     d.lnr2  = last_t.lnr2\n    #     d.x2    = last_t.x2\n    #.......................................................................................................\n    $parse = => parse = ( source, send ) =>\n      send token for token from @_lexer.walk source\n    # #.......................................................................................................\n    # $mark_active = =>\n    #   active = @cfg.active\n    #   set_active = ( d, active ) => lets d, ( d ) =>\n    #     d.data         ?= {}\n    #     d.data.active   = active\n    #   return mark_active = ( d, send ) =>\n    #     if d.mk is 'meta:start'\n    #       active = true\n    #       return send set_active d, false\n    #     if d.mk is 'meta:stop'\n    #       active = false\n    #       return send set_active d, false\n    #     send set_active d, active\n    # #.......................................................................................................\n    # $collect_chunks = =>\n    #   collector = []\n    #   active    = null\n    #   last      = Symbol 'last'\n    #   #.....................................................................................................\n    #   return collect_chunks = $ { last, }, ( d, send ) =>\n    #     if d is last\n    #       send join collector, { joiner: '', } if collector.length > 0\n    #       collector = []\n    #       return null\n    #     if d.mk is 'meta:nl'\n    #       collector.push d\n    #       send join collector, { joiner: '', }\n    #       collector = []\n    #     else if active isnt d.data.active\n    #       send join collector, { joiner: '', } if collector.length > 0\n    #       collector = [ d, ]\n    #     else\n    #       collector.push d\n    #     active = d.data.active\n    # #.......................................................................................................\n    # $assemble_lines = =>\n    #   collector = []\n    #   last      = Symbol 'last'\n    #   prv_lnr1  = null\n    #   join_cfg  = {}\n    #   join_cfg.joiner = @cfg.joiner if @cfg.joiner?\n    #   join_cfg.eraser = @cfg.eraser if @cfg.eraser?\n    #   #.....................................................................................................\n    #   return assemble_lines = $ { last, }, ( d, send ) =>\n    #     if d is last\n    #       send join collector, join_cfg if collector.length > 0\n    #       collector = []\n    #       return null\n    #     return send d unless d.data.active\n    #     prv_lnr1 ?= d.lnr1\n    #     if d.lnr1 isnt prv_lnr1\n    #       prv_lnr1 = d.lnr1\n    #       send join collector, join_cfg if collector.length > 0\n    #       collector = []\n    #       collector.push d\n    #       return null\n    #     collector.push d\n    #     return null\n    #.......................................................................................................\n    p.push $parse()\n    # p.push ( d ) -> urge '^77-1^', d\n    return p\n"
  ]
}