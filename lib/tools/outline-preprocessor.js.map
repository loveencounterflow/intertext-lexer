{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../../src/tools/outline-preprocessor.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERLEX/START-STOP-PREPROC'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n{ misfit\n  get_base_types }        = require '../types'\nlets                      = GUY.lft.lets\n{ Transformer\n  $           }           = require 'moonriver'\n\n\n\n#===========================================================================================================\n_new_prelexer = ( cfg ) ->\n  { Interlex }  = require '../main'\n  lexer         = new Interlex { split: 'lines', cfg..., }\n  #.......................................................................................................\n  do =>\n    mode = 'outline'\n    create = ( token ) =>\n      token.data           ?= {}\n      token.data.indent    ?= ''\n      token.data.material  ?= ''\n      token.data.spc_count  = token.data.indent.length\n      return token\n    ### NOTE consider to allow escaping newlines ###\n    # lexer.add_lexeme { mode, tid: 'escchr',         pattern: /\\\\(?<chr>.)/u,                      reserved: '\\\\', }\n    lexer.add_lexeme { mode, tid: 'nl',       value: '\\n',  pattern: /$/u, }\n    lexer.add_lexeme { mode, tid: 'material', create,       pattern: /^(?<indent>\\x20*)(?<material>.+)$/, }\n  #.......................................................................................................\n  return lexer\n\n#===========================================================================================================\n@$010_lexing = class $010_lexing extends Transformer\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ->\n    super()\n    GUY.props.hide @, '_lexer', _new_prelexer()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  $parse: => parse = ( source, send ) =>\n    send token for token from @_lexer.walk source\n    return null\n\n#===========================================================================================================\n@$020_consolidate = class $020_consolidate extends $010_lexing\n\n  #---------------------------------------------------------------------------------------------------------\n  $consolidate_newlines: ->\n    { Interlex }  = require '../main'\n    count         = 0\n    position      = null\n    stop          = Symbol 'stop'\n    template      = { mode: 'plain', tid: 'nls', mk: 'plain:nls', $: '^outliner.020^', }\n    #.......................................................................................................\n    flush = ( send ) =>\n      return null if count is 0\n      value         = '\\n'.repeat count\n      position.lnr2 = position.lnr1 + count\n      if count > 1\n        position.lnr2 = position.lnr1 + count - 1\n        position.x2   = 0\n      data          = { count, }\n      nls           = { template..., value, data, position..., }\n      count         = 0\n      position      = null\n      send nls\n    #.......................................................................................................\n    return $ { stop, }, consolidate_newlines = ( d, send ) =>\n      return flush send if d is stop\n      return send d if d.$stamped\n      if d.mk is 'outline:nl'\n        count++\n        position ?= Interlex.get_token_position d\n      else\n        flush send\n        send d\n      return null\n\n\n#===========================================================================================================\n@$030_structure = class $030_structure extends Transformer\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ->\n    super()\n    GUY.props.hide @, '_lexer', _new_prelexer()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  $structure: => structure = ( source, send ) =>\n    send token for token from @_lexer.walk source\n    return null\n\n#===========================================================================================================\nclass @Outline_preprocessor\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @types        = get_base_types()\n    @cfg          = Object.freeze @types.create.ilx_outline_preprocessor_cfg cfg\n    @_lexer       = @_new_prelexer()\n    @_parser      = @_new_preparser()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source_or_cfg ) -> @_parser.send source_or_cfg; yield from @_parser.walk()\n  run:  ( source_or_cfg ) -> [ ( @walk source_or_cfg )..., ]\n\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_preparser: ->\n    { Pipeline\n      $         } = require 'moonriver'\n    p             = new Pipeline()\n    # #.......................................................................................................\n    # join = ( collector, joinerase ) =>\n    #   { joiner\n    #     eraser }  = joinerase\n    #   first_t     = collector.at 0\n    #   last_t      = collector.at -1\n    #   return lets first_t, ( d ) =>\n    #     #...................................................................................................\n    #     if joiner?\n    #       d.value = ( ( t.value for t in collector ).join joiner ).trimEnd()\n    #     else\n    #       parts     = []\n    #       last_idx  = collector.length - 1\n    #       for t, idx in collector\n    #         parts.push t.value\n    #         continue if idx >= last_idx\n    #         parts.push eraser.repeat distance if ( distance = collector[ idx + 1 ].x1 - t.x2 ) > 0\n    #       d.value = ( parts.join '' ).trimEnd()\n    #     #...................................................................................................\n    #     d.lnr1  = first_t.lnr1\n    #     d.x1    = first_t.x1\n    #     d.lnr2  = last_t.lnr2\n    #     d.x2    = last_t.x2\n    #.......................................................................................................\n    # #.......................................................................................................\n    # $mark_active = =>\n    #   active = @cfg.active\n    #   set_active = ( d, active ) => lets d, ( d ) =>\n    #     d.data         ?= {}\n    #     d.data.active   = active\n    #   return mark_active = ( d, send ) =>\n    #     if d.mk is 'meta:start'\n    #       active = true\n    #       return send set_active d, false\n    #     if d.mk is 'meta:stop'\n    #       active = false\n    #       return send set_active d, false\n    #     send set_active d, active\n    # #.......................................................................................................\n    # $collect_chunks = =>\n    #   collector = []\n    #   active    = null\n    #   last      = Symbol 'last'\n    #   #.....................................................................................................\n    #   return collect_chunks = $ { last, }, ( d, send ) =>\n    #     if d is last\n    #       send join collector, { joiner: '', } if collector.length > 0\n    #       collector = []\n    #       return null\n    #     if d.mk is 'meta:nl'\n    #       collector.push d\n    #       send join collector, { joiner: '', }\n    #       collector = []\n    #     else if active isnt d.data.active\n    #       send join collector, { joiner: '', } if collector.length > 0\n    #       collector = [ d, ]\n    #     else\n    #       collector.push d\n    #     active = d.data.active\n    # #.......................................................................................................\n    # $assemble_lines = =>\n    #   collector = []\n    #   last      = Symbol 'last'\n    #   prv_lnr1  = null\n    #   join_cfg  = {}\n    #   join_cfg.joiner = @cfg.joiner if @cfg.joiner?\n    #   join_cfg.eraser = @cfg.eraser if @cfg.eraser?\n    #   #.....................................................................................................\n    #   return assemble_lines = $ { last, }, ( d, send ) =>\n    #     if d is last\n    #       send join collector, join_cfg if collector.length > 0\n    #       collector = []\n    #       return null\n    #     return send d unless d.data.active\n    #     prv_lnr1 ?= d.lnr1\n    #     if d.lnr1 isnt prv_lnr1\n    #       prv_lnr1 = d.lnr1\n    #       send join collector, join_cfg if collector.length > 0\n    #       collector = []\n    #       collector.push d\n    #       return null\n    #     collector.push d\n    #     return null\n    #.......................................................................................................\n    p.push $parse()\n    # p.push ( d ) -> urge '^77-1^', d\n    return p\n\n\n\n\n"
  ]
}