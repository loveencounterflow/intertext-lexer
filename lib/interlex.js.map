{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/interlex.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n{ misfit\n  jump_symbol\n  get_base_types }        = require './types'\nE                         = require './errors'\n#...........................................................................................................\n_CRX  = require 'compose-regexp-commonjs'\n_X    =\n  unicode:    ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true,   } else flags.add 'u', x\n  sticky:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,    } else flags.add 'y', x\n  dotall:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,    } else flags.add 's', x\n  multiline:  ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { multiline: true, } else flags.add 'm', x\n_X.dotAll = _X.dotall\ncompose   = C = { _CRX..., _X..., }\n#...........................................................................................................\n{ DATOM }                 = require 'datom'\n{ new_datom\n  lets      }             = DATOM\n{ Ltsort }                = require 'ltsort'\n\n\n#===========================================================================================================\nclass Interlex\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @types        = get_base_types()\n    @cfg          = Object.freeze @types.create.ilx_constructor_cfg cfg\n    @start()\n    @base_mode    = null\n    @registry     = {}\n    @_metachr     = '𝔛' # used for identifying group keys\n    @_metachrlen  = @_metachr.length\n    @jump_symbol  = jump_symbol\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexeme: ( cfg ) ->\n    cfg                         = @types.create.ilx_add_lexeme_cfg cfg\n    @state.finalized            = false\n    @base_mode                 ?= cfg.mode\n    entry                       = @_get_mode_entry cfg\n    entry.toposort            or= cfg.needs? or cfg.precedes?\n    type_of_jump                = @_get_type_of_jump cfg.jump\n    #.......................................................................................................\n    if entry.lexemes[ cfg.tid ]?\n      throw new E.Interlex_lexeme_exists '^interlex.add_lexeme@1^', cfg.mode, cfg.tid\n    #.......................................................................................................\n    entry.lexemes[ cfg.tid ]    = lexeme = { cfg..., type_of_jump, }\n    lexeme.pattern              = @_rename_groups lexeme.tid, lexeme.pattern if @types.isa.regex lexeme.pattern\n    lexeme.pattern              = C.namedCapture ( @_metachr + cfg.tid ), lexeme.pattern\n    lexeme.type_of_value        = @types.type_of entry.value\n    lexeme.type_of_empty_value  = @types.type_of entry.empty_value\n    @_add_reserved_chrs cfg.mode, cfg.reserved if cfg.reserved?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_mode_entry: ( cfg ) ->\n    return R if ( R = @registry[ cfg.mode ] )?\n    ### TAINT use @types.create.ilx_registry_mode_entry ###\n    R =\n      lexemes:        {}\n      pattern:        null\n      toposort:       false\n      reserved_chrs:  new Set()\n      value:          cfg.value\n      empty_value:    cfg.empty_value\n      catchall:       null\n      reserved:       null\n    @registry[ cfg.mode ] = R\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_type_of_jump: ( jump ) ->\n    return 'nojump'   if not jump?\n    return 'popmode'  if jump is jump_symbol\n    return 'callme'   if @types.isa.function jump\n    return 'pushmode' if @types.isa.nonempty.text jump\n    @types.validate.ilx_jump jump\n    throw new E.Interlex_internal_error '^interlex._get_type_of_jump@1^', \\\n      \"jump (#{@types.type_of jump}) #{rpr jump} should have caused validation error but didn't\"\n\n  #---------------------------------------------------------------------------------------------------------\n  _rename_groups: ( name, re ) ->\n    source = re.source.replace /(?:(?<=\\\\\\\\)|(?<!\\\\))\\(\\?<([^>]+)>/gu, \"(?<#{name}#{@_metachr}$1>\"\n    return new RegExp source, re.flags\n\n  #---------------------------------------------------------------------------------------------------------\n  _toposort_patterns: ( entry ) ->\n    ### TAINT avoid re-running ###\n    return entry unless entry.toposort\n    g   = new Ltsort()\n    tmp = Object.assign {}, entry.lexemes ### NOTE avoiding shorthand for clarity ###\n    for tid, lexeme of entry.lexemes\n      tmp[ tid ]  = lexeme\n      delete entry.lexemes[ tid ]\n      needs       = lexeme.needs  ? []\n      precedes      = lexeme.precedes ? []\n      g.add { name: tid, needs, precedes, }\n    for tid in g.linearize()\n      entry.lexemes[ tid ] = tmp[ tid ]\n    return entry\n\n  #---------------------------------------------------------------------------------------------------------\n  _set_u_flag: ( patterns ) ->\n    for pattern, idx in patterns\n      continue if ( not @types.isa.regex pattern ) or ( pattern.unicode )\n      patterns[ idx ] = compose.unicode pattern\n    return patterns\n\n  #---------------------------------------------------------------------------------------------------------\n  _finalize: ->\n    return unless @state?\n    for mode, entry of @registry\n      entry                     = @_toposort_patterns entry\n      #.....................................................................................................\n      @_add_catchall_lexeme mode, entry.catchall.tid, entry if entry.catchall?\n      @_add_reserved_lexeme mode, entry.reserved.tid, entry if entry.reserved?\n      #.....................................................................................................\n      ### TAINT use API ###\n      patterns                  = @_set_u_flag ( lexeme.pattern for tid, lexeme of entry.lexemes )\n      pattern                   = C.either patterns...\n      ### TAINT could / should set all flags in single step ###\n      pattern                   = C.dotall    pattern if @cfg.dotall\n      pattern                   = C.multiline pattern if @cfg.multiline\n      @registry[ mode ].pattern = C.sticky C.unicode pattern\n    for mode, entry of @registry\n      for tid, lexeme of entry.lexemes\n        continue if lexeme.type_of_jump isnt 'pushmode'\n        continue if @registry[ lexeme.jump ]?\n        throw new E.Interlex_TBDUNCLASSIFIED '^interlex._finalize@1^', \"unknown jump target in lexeme #{rpr lexeme}\"\n    @state.finalized = true\n    return null\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  start: ( source = null ) ->\n    @types.validate.optional.text source\n    return @_start source\n\n  #---------------------------------------------------------------------------------------------------------\n  _start: ( source = null ) ->\n    ### TAINT use `@types.create.ilx_state()` ###\n    @_finalize() if @state? and not @state.finalized\n    @state                             ?= {}\n    @state.finalized                   ?= false\n    @state.stack                       ?= []\n    @state.prv_last_idx                 = 0\n    @state.mode                        ?= @base_mode ? null\n    @state.pattern                      = @registry?[ @state.mode ]?.pattern ? null\n    @state.source                       = source\n    @state.finished                     = false\n    @registry[ mode ].pattern.lastIndex = 0 for mode, entry of @registry\n    if @cfg.linewise\n      @state.lnr1    ?= @cfg.lnr1 - 1\n      @state.eol     ?= ''\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  feed: ( source_or_cfg ) ->\n    return @_feed_source  source_or_cfg if @types.isa.text source_or_cfg\n    return @_feed_cfg     source_or_cfg\n\n  #---------------------------------------------------------------------------------------------------------\n  _feed_cfg: ( cfg ) ->\n    @state.eol  = ( cfg.eol ? '' ) if @cfg.linewise\n    return @_feed_source cfg.source\n\n  #---------------------------------------------------------------------------------------------------------\n  _feed_source: ( source ) ->\n    @state.lnr1++ if @cfg.linewise\n    @types.validate.text source\n    return @_start source if @cfg.autostart\n    @state.source = source\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  rpr_token: ( token ) ->\n    # @types.validate.ilx_token token\n    t = token\n    j = token.jump\n    R = []\n    R.push t.mk + if j? then ( if j is jump_symbol then j else \">#{j}\") else ''\n    if @cfg.linewise then R.push \"(#{t.lnr1}:#{t.x1})(#{t.lnr2}:#{t.x2})\"\n    else                  R.push \"(1:#{t.x1})(1:#{t.x2})\"\n    R.push \"=#{rpr t.value}\"\n    R.push \"#{k}:#{rpr v}\" for k, v of t.x ? {}\n    return \"[#{R.join ','}]\"\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_token: ( tid, value, length, x = null, lexeme = null ) ->\n    x1        = @state.prv_last_idx\n    x2        = x1 + length\n    jump      = lexeme?.jump ? null\n    { source\n      mode  } = @state\n    #.......................................................................................................\n    ### TAINT use `types.create.ilx_token {}` ###\n    if @cfg.linewise\n      lnr1  = lnr2 = @state.lnr1\n      R     = { mode, tid, mk: \"#{mode}:#{tid}\", jump, value, lnr1, x1, lnr2, x2, x, source, }\n    else\n      R     = { mode, tid, mk: \"#{mode}:#{tid}\", jump, value,       x1,       x2, x, source, }\n    #.......................................................................................................\n    @_set_entry_value R, lexeme, value\n    #.......................................................................................................\n    if lexeme?.create?\n      R = lexeme.create.call @, R\n    return new_datom \"^#{mode}\", R\n\n  #---------------------------------------------------------------------------------------------------------\n  _set_entry_value: ( entry, lexeme, value ) ->\n    if lexeme?.empty_value? and ( ( not entry.value? ) or ( entry.value is '' ) )\n      switch lexeme.type_of_empty_value\n        when 'text'     then entry.value  = lexeme.empty_value\n        when 'function' then entry.value  = lexeme.empty_value.call @, entry\n        else throw new E.Interlex_internal_error '^_new_token@1^', \\\n          \"unknown type of lexeme.empty_value: #{rpr lexeme.type_of_empty_value}\"\n    else if lexeme?.value?\n      switch lexeme.type_of_value\n        when 'text'     then entry.value  = lexeme.value\n        when 'function' then entry.value  = lexeme.value.call       @, entry\n        else throw new E.Interlex_internal_error '^_new_token@2^', \\\n          \"unknown type of lexeme.value: #{rpr lexeme.type_of_value}\"\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _token_and_lexeme_from_match: ( match ) ->\n    x = null\n    for key, value of match.groups\n      continue unless value?\n      if key.startsWith @_metachr\n        token_tid           = key[ @_metachrlen .. ]\n        token_value         = value\n      else\n        key                 = ( key.split @_metachr )[ 1 ]\n        ( x ?= {} )[ key ]  = if value is '' then null else value\n    lexeme  = @registry[ @state.mode ].lexemes[ token_tid ]\n    token   = @_new_token token_tid, token_value, match[ 0 ].length, x, lexeme\n    return { token, lexeme, }\n\n  #---------------------------------------------------------------------------------------------------------\n  run: ( source_or_cfg ) -> [ ( @walk source_or_cfg )..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source_or_cfg ) ->\n    cfg = @types.cast.ilx_walk_source_or_cfg source_or_cfg\n    return @_walk_text        cfg if cfg.source?\n    return @_walk_file_lines  cfg\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_file_lines: ( cfg ) ->\n    ### TAINT should provide `lnr1`, `eol` as well ###\n    ### TAINT derive `cfg` for line iterator (`trim`, `chunk_size`) ###\n    for { line, } from GUY.fs.walk_lines_with_positions cfg.path, { trim: @cfg.trim, }\n      yield from @_walk_text { cfg..., source: line, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text: ( cfg ) ->\n    return @_walk_text_lines cfg if @cfg.linewise\n    return @_walk_text_whole cfg\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text_whole: ( cfg ) ->\n    @feed cfg\n    #.......................................................................................................\n    loop\n      break if @state.finished\n      yield Y if ( Y = @step() )?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text_lines: ( cfg ) ->\n    for { lnr: lnr1, line, eol, } from GUY.str.walk_lines_with_positions cfg.source, { trim: @cfg.trim, }\n      yield from @_walk_text_whole { cfg..., lnr1, source: line, eol, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  step: ->\n    #.......................................................................................................\n    ### Affordance for lexemes matching only end-of-input (pattern `/$/y`): ###\n    if ( @state.prv_last_idx is @state.source.length ) and ( match = @state.source.match @state.pattern )?\n      ### TAINT code duplication ###\n      { token\n        lexeme          } = @_token_and_lexeme_from_match match\n      token               = @_get_next_token lexeme, token, match\n      @state.prv_last_idx = @state.pattern.lastIndex + 1\n      return token\n    #.......................................................................................................\n    if @state.prv_last_idx >= @state.source.length\n      ### reached end ###\n      @state.finished     = true\n      token               = @_new_token '$eof', '', 0 if @cfg.end_token\n      return token\n    #.......................................................................................................\n    match = @state.source.match @state.pattern\n    #.......................................................................................................\n    unless match?\n      ### TAINT might want to advance and try again? ###\n      @state.finished  = true\n      token            = @_new_token '$error', '', 0, { code: 'nomatch', }\n      return token\n    #.......................................................................................................\n    if @state.pattern.lastIndex is @state.prv_last_idx\n      if match?\n        { token } = @_token_and_lexeme_from_match match\n        ### TAINT uses code units, should use codepoints ###\n        center    = token.x2\n        left      = Math.max 0, center - 11\n        right     = Math.min @state.source.length, center + 11\n        before    = @state.source[ left ... center ]\n        after     = @state.source[ center + 1 .. right ]\n        mid       = @state.source[ center ]\n        ### TAINT raise error or return error token ###\n        warn '^31-9^', { before, mid, after, }\n        warn '^31-10^', GUY.trm.reverse \"pattern #{rpr token.tid} matched empty string; stopping\"\n        @state.finished = true\n      else\n        ### TAINT raise error or return error token ###\n        warn '^31-11^', GUY.trm.reverse \"nothing matched; detected loop, stopping\"\n        @state.finished = true\n        return null\n    #.......................................................................................................\n    { token\n      lexeme          } = @_token_and_lexeme_from_match match\n    token               = @_get_next_token lexeme, token, match\n    @state.prv_last_idx = @state.pattern.lastIndex\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  _call_jump_handler: ( lexeme, token, match ) ->\n    divert = lexeme.jump { token, match, lexer: @, }\n    return { token, jump: null, type_of_jump: 'nojump', } unless divert?\n    if @types.isa.text divert\n      return { token, jump: jump_symbol,  type_of_jump: 'popmode',  } if divert is jump_symbol\n      return { token, jump: divert,       type_of_jump: 'pushmode', }\n    if @types.isa.function divert\n      throw new E.Interlex_TBDUNCLASSIFIED '^interlex._call_jump_handler@1^', \\\n        \"jump handler of lexeme #{rpr lexeme.mk} returned illegal value #{rpr divert}\"\n    token         = replacement_token if ( replacement_token = divert.token )?\n    jump          = divert.jump ? null\n    type_of_jump  = @_get_type_of_jump jump\n    return { token, jump, type_of_jump, }\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_next_token: ( lexeme, token, match ) ->\n    switch lexeme.type_of_jump\n      when 'nojump'   then null\n      when 'pushmode' then @_push_mode lexeme.jump\n      when 'popmode'\n        @_pop_mode()\n        token = lets token, ( token ) => token.jump = @state.mode\n      when 'callme'\n        { token\n          jump\n          type_of_jump } = @_call_jump_handler lexeme, token, match\n        # debug '^2343^', ( rpr jump ), token\n        switch type_of_jump\n          when 'nojump'   then null\n          when 'pushmode' then @_push_mode jump\n          when 'popmode'  then @_pop_mode()\n          else\n            throw new E.Interlex_internal_error '^interlex._get_next_token@1^', \\\n              \"unknown type_of_jump #{rpr type_of_jump} in lexeme #{rpr lexeme}\"\n        token = lets token, ( token ) => token.jump = if type_of_jump is 'nojump' then null else @state.mode\n      else\n        throw new E.Interlex_internal_error '^interlex._get_next_token@2^', \\\n          \"unknown type_of_jump in lexeme #{rpr lexeme}\"\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  _pop_mode: ->\n    unless @state.stack.length > 0\n      throw new E.Interlex_mode_stack_exhausted '^interlex._pop_mode@2^', \\\n        \"unable to jump back from initial state\"\n    @state.mode               = @state.stack.pop()\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _push_mode: ( jump ) ->\n    @state.stack.push @state.mode\n    @state.mode               = jump\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return null\n\n\n  #=========================================================================================================\n  # CATCHALL & RESERVED\n  #---------------------------------------------------------------------------------------------------------\n  _add_reserved_chrs: ( mode, reserved_chrs ) ->\n    unless ( entry = @registry[ mode ] )?\n      throw new E.Interlex_internal_error '^interlex._add_reserved_chrs@1^', \"no such mode: #{rpr mode}\"\n    if @types.isa.list reserved_chrs\n      @_add_reserved_chrs mode, x for x in reserved_chrs\n      return null\n    ### NOTE may accept regexes in the future ###\n    @types.validate.nonempty.text reserved_chrs\n    entry.reserved_chrs.add reserved_chrs\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_catchall_regex: ( mode, entry ) -> compose.charSet.complement @_get_reserved_regex mode, entry\n  _get_reserved_regex: ( mode, entry ) -> compose.either entry.reserved_chrs...\n\n  #---------------------------------------------------------------------------------------------------------\n  _add_catchall_lexeme: ( mode, tid, entry ) ->\n    pattern = @_get_catchall_regex mode, entry\n    pattern = compose.suffix '+', pattern if @cfg.catchall_concat\n    @add_lexeme { mode, tid, pattern, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _add_reserved_lexeme: ( mode, tid, entry ) ->\n    pattern = @_get_reserved_regex mode, entry\n    pattern = compose.suffix '+', pattern if @cfg.reserved_concat\n    @add_lexeme { mode, tid, pattern, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  add_catchall_lexeme: ( cfg ) ->\n    cfg       = @types.create.ilx_add_catchall_lexeme_cfg cfg\n    cfg.mode ?= @base_mode\n    unless ( entry = @registry[ cfg.mode ] )?\n      throw new E.Interlex_mode_unknown '^interlex.add_catchall_lexeme@1^', cfg.mode\n    if entry.catchall?\n      throw new E.Interlex_catchall_exists '^interlex.add_catchall_lexeme@1^', cfg.mode, entry.catchall.tid\n    entry.catchall = cfg\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  add_reserved_lexeme: ( cfg ) ->\n    cfg       = @types.create.ilx_add_reserved_lexeme_cfg cfg\n    cfg.mode ?= @base_mode\n    unless ( entry = @registry[ cfg.mode ] )?\n      throw new E.Interlex_mode_unknown '^interlex.add_reserved_lexeme@1^', cfg.mode\n    if entry.reserved?\n      throw new E.Interlex_reserved_exists '^interlex.add_reserved_lexeme@1^', cfg.mode, entry.reserved.tid\n    entry.reserved = cfg\n    return null\n\n\n#===========================================================================================================\nmodule.exports = { Interlex, compose, }\n\n"
  ]
}