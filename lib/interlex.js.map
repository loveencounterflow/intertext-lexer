{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/interlex.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n{ misfit\n  get_base_types }        = require './types'\nE                         = require './errors'\n#...........................................................................................................\n_CRX  = require 'compose-regexp-commonjs'\n_X    =\n  unicode:    ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true,   } else flags.add 'u', x\n  sticky:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,    } else flags.add 'y', x\n  dotall:     ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,    } else flags.add 's', x\n  multiline:  ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { multiline: true, } else flags.add 'm', x\n_X.dotAll = _X.dotall\ncompose   = C = { _CRX..., _X..., }\n#...........................................................................................................\n{ DATOM }                 = require 'datom'\n{ new_datom\n  lets\n  freeze }                = DATOM\n{ Ltsort }                = require 'ltsort'\nsorter                    = ( require './sorter' ).sorter\n\n\n#===========================================================================================================\nget_token_mode          = ( token ) -> ( token.$key.split ':' )[ 0 ]\n### TAINT in future version, will want LXID to always start with colon ###\nget_token_lxid          = ( token ) -> token.$key.replace /^[^:]*:/, ''\nset_token_mode          = ( token ) -> lets token, ( token, mode ) -> _set_token_mode token, mode\n### NODE play safe, avoid [A$$es](https://github.com/loveencounterflow/gaps-and-islands#regular-expressions-how-to-avoid-accidental-string-substitutions-so-called-aes) ###\n_set_token_mode         = ( token, mode ) -> token.$key = token.$key.replace /^[^:]+/, -> mode\n_split_token_mode_lxid  = ( token ) -> ( token.$key.split /^([^:]+):(.*)$/ )[ 1 .. 2 ]\n\n\n#===========================================================================================================\nclass Interlex\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @types        = get_base_types()\n    @cfg          = Object.freeze @types.create.ilx_interlex_constructor_cfg cfg\n    @start()\n    @base_mode    = null\n    @registry     = {}\n    @_metachr     = '𝔛' # used for identifying group keys\n    @_metachrlen  = @_metachr.length\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexeme: ( cfg ) ->\n    cfg                         = @types.create.ilx_add_lexeme_cfg cfg\n    @state.finalized            = false\n    @base_mode                 ?= cfg.mode\n    entry                       = @_get_mode_entry cfg\n    entry.toposort            or= cfg.needs? or cfg.precedes?\n    { jump_action\n      jump_time\n      jump_target             } = @_parse_jump_cfg cfg.jump\n    #.......................................................................................................\n    if entry.lexemes[ cfg.lxid ]?\n      throw new E.Interlex_lexeme_exists '^interlex.add_lexeme@1^', cfg.mode, cfg.lxid\n    #.......................................................................................................\n    entry.lexemes[ cfg.lxid ]   = lexeme = { cfg..., jump_action, jump_time, jump_target, }\n    lexeme.pattern              = @_rename_groups lexeme.lxid, lexeme.pattern if @types.isa.regex lexeme.pattern\n    lexeme.pattern              = C.namedCapture ( @_metachr + cfg.lxid ), lexeme.pattern\n    lexeme.type_of_value        = @types.type_of lexeme.value\n    lexeme.type_of_empty_value  = @types.type_of lexeme.empty_value\n    @_add_reserved_chrs cfg.mode, cfg.reserved if cfg.reserved?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_mode_entry: ( cfg ) ->\n    return R if ( R = @registry[ cfg.mode ] )?\n    ### TAINT use @types.create.ilx_registry_mode_entry ###\n    R =\n      lexemes:        {}\n      pattern:        null\n      toposort:       false\n      reserved_chrs:  new Set()\n      value:          cfg.value\n      empty_value:    cfg.empty_value\n      catchall:       null\n      reserved:       null\n    @registry[ cfg.mode ] = R\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _parse_jump_cfg: ( jump ) ->\n    return { jump_action: 'nojump',  jump_time: null, jump_target: null } unless jump?\n    return { jump_action: 'callme',  jump_time: null, jump_target: null } if ( type = @types.type_of jump ) is 'function'\n    #.......................................................................................................\n    unless type is 'text' and jump.length > 1\n      throw new E.Interlex_illegal_jump_target '^interlex._parse_jump_cfg@1^', type, jump\n    #.......................................................................................................\n    return { jump_action: 'popmode', jump_time: 'inclusive', jump_target: null } if jump is '.]'\n    return { jump_action: 'popmode', jump_time: 'exclusive', jump_target: null } if jump is '].'\n    #.......................................................................................................\n    if ( jump.startsWith '[' ) and ( jump.endsWith ']' )\n      return { jump_action: 'pushpop',  jump_time: 'inclusive', jump_target: jump[ 1 ... jump.length - 1 ], }\n    if jump.startsWith '['\n      return { jump_action: 'pushmode', jump_time: 'inclusive', jump_target: jump[ 1  ..                 ], }\n    if jump.endsWith   '['\n      return { jump_action: 'pushmode', jump_time: 'exclusive', jump_target: jump[   ... jump.length - 1 ], }\n    #.......................................................................................................\n    throw new E.Interlex_illegal_jump_target '^interlex._parse_jump_cfg@2^', type, jump\n\n  #---------------------------------------------------------------------------------------------------------\n  _rename_groups: ( name, re ) ->\n    source = re.source.replace /(?:(?<=\\\\\\\\)|(?<!\\\\))\\(\\?<([^>=!]+)>/gu, \"(?<#{name}#{@_metachr}$1>\"\n    return new RegExp source, re.flags\n\n  #---------------------------------------------------------------------------------------------------------\n  _toposort_patterns: ( entry ) ->\n    ### TAINT avoid re-running ###\n    return entry unless entry.toposort\n    g   = new Ltsort()\n    tmp = Object.assign {}, entry.lexemes ### NOTE avoiding shorthand for clarity ###\n    for lxid, lexeme of entry.lexemes\n      tmp[ lxid ]  = lexeme\n      delete entry.lexemes[ lxid ]\n      needs       = lexeme.needs  ? []\n      precedes      = lexeme.precedes ? []\n      g.add { name: lxid, needs, precedes, }\n    for lxid in g.linearize()\n      entry.lexemes[ lxid ] = tmp[ lxid ]\n    return entry\n\n  #---------------------------------------------------------------------------------------------------------\n  _set_u_flag: ( patterns ) ->\n    for pattern, idx in patterns\n      continue if ( not @types.isa.regex pattern ) or ( pattern.unicode )\n      patterns[ idx ] = compose.unicode pattern\n    return patterns\n\n  #---------------------------------------------------------------------------------------------------------\n  _finalize: ->\n    return unless @state?\n    for mode, entry of @registry\n      entry                     = @_toposort_patterns entry\n      #.....................................................................................................\n      @_add_catchall_lexeme mode, entry.catchall.lxid, entry if entry.catchall?\n      @_add_reserved_lexeme mode, entry.reserved.lxid, entry if entry.reserved?\n      #.....................................................................................................\n      ### TAINT use API ###\n      patterns                  = @_set_u_flag ( lexeme.pattern for lxid, lexeme of entry.lexemes )\n      pattern                   = C.either patterns...\n      ### TAINT could / should set all flags in single step ###\n      pattern                   = C.dotall    pattern if @cfg.dotall\n      pattern                   = C.multiline pattern if @cfg.multiline\n      @registry[ mode ].pattern = C.sticky C.unicode pattern\n    for mode, entry of @registry\n      for lxid, lexeme of entry.lexemes\n        continue if lexeme.jump_action isnt 'pushmode'\n        continue if @registry[ lexeme.jump_target ]?\n        throw new E.Interlex_mode_unknown '^interlex._finalize@1^', lexeme.jump_target\n    @state.finalized = true\n    return null\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  start: ( source = null ) ->\n    @types.validate.optional.text source\n    return @_start source\n\n  #---------------------------------------------------------------------------------------------------------\n  ### For user override ###\n  reset: ->\n\n  #---------------------------------------------------------------------------------------------------------\n  _start: ( source = null ) ->\n    ### TAINT use `@types.create.ilx_state()` ###\n    @_finalize() if @state? and not @state.finalized\n    call_reset                          = @state?\n    @state                             ?= {}\n    @state.finalized                   ?= false\n    switch @cfg.state\n      when 'keep'\n        @state.stack                       ?= []\n        @state.mode                        ?= @base_mode ? null\n      when 'reset'\n        @state.stack                        = []\n        @state.mode                         = @base_mode ? null\n      else\n        throw new E.Interlex_TBDUNCLASSIFIED '^_start@1^', \"illegal value for @cfg.state: #{rpr @cfg.state}\"\n    @state.prv_last_idx                 = 0\n    @state.delta_x                      = @state.posapi_x1 ? 0\n    @state.posapi_x1                    = null\n    @state.pattern                      = @registry?[ @state.mode ]?.pattern ? null\n    @state.source                       = source\n    @state.finished                     = false\n    @registry[ mode ].pattern.lastIndex = 0 for mode, entry of @registry\n    #.......................................................................................................\n    if @cfg.split is 'lines'\n      @state.lnr1    ?= 0\n      @state.eol     ?= ''\n    else\n      @state.lnr1     = 0\n    #.......................................................................................................\n    @reset() if call_reset\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  feed: ( source_or_cfg ) ->\n    return @_feed_source  source_or_cfg if @types.isa.text source_or_cfg\n    return @_feed_cfg     source_or_cfg\n\n  #---------------------------------------------------------------------------------------------------------\n  _feed_cfg: ( cfg ) ->\n    @state.eol  = ( cfg.eol ? '' ) if ( @cfg.split is 'lines' )\n    return @_feed_source cfg.source\n\n  #---------------------------------------------------------------------------------------------------------\n  _feed_source: ( source ) ->\n    @state.lnr1++ if ( @cfg.split is 'lines' )\n    @types.validate.text source\n    return @_start source # if @cfg.autostart\n    @state.source = source\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  rpr_token: ( token ) ->\n    # @types.validate.ilx_token token\n    t = token\n    R = []\n    if token.jump?\n      [ mode\n        lxid  ] =   _split_token_mode_lxid token\n      j         = @registry[ mode ]?.lexemes[ lxid ]?.jump ? null\n      j         = \"<#{j}>\" if j?\n      j        ?= ''\n    else\n      j   = ''\n    R.push t.$key + j\n    R.push \"(#{t.lnr1}:#{t.x1})(#{t.lnr2}:#{t.x2})\"\n    R.push \"=#{rpr t.value}\"\n    R.push \"#{k}:#{rpr v}\" for k, v of t.data ? {}\n    return \"[#{R.join ','}]\"\n\n  #---------------------------------------------------------------------------------------------------------\n  _new_token: ( lxid, value, length, data = null, lexeme = null ) ->\n    x1        = @state.prv_last_idx + @state.delta_x\n    x2        = x1 + length\n    jump      = lexeme?.jump ? null\n    { source\n      mode  } = @state\n    $key      = \"#{mode}:#{lxid}\"\n    lnr1      = lnr2 = @state.lnr1\n    pretoken  = { $key, jump, value, lnr1, x1, lnr2, x2, data, source, }\n    @_set_token_value pretoken, lexeme, value\n    R         = if lexeme?.create? then ( lexeme.create.call @, pretoken ) else pretoken\n    return freeze R\n\n  #---------------------------------------------------------------------------------------------------------\n  _set_token_value: ( token, lexeme, value ) ->\n    if lexeme?.empty_value? and ( ( not token.value? ) or ( token.value is '' ) )\n      switch lexeme.type_of_empty_value\n        when 'text'     then token.value  = lexeme.empty_value\n        when 'function' then token.value  = lexeme.empty_value.call @, token\n        else throw new E.Interlex_internal_error '^_new_token@1^', \\\n          \"unknown type of lexeme.empty_value: #{rpr lexeme.type_of_empty_value}\"\n    else if lexeme?.value?\n      switch lexeme.type_of_value\n        when 'text'     then token.value  = lexeme.value\n        when 'function' then token.value  = lexeme.value.call       @, token\n        else throw new E.Interlex_internal_error '^_new_token@2^', \\\n          \"unknown type of lexeme.value: #{rpr lexeme.type_of_value}\"\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _token_and_lexeme_from_match: ( match ) ->\n    data = null\n    for key, value of match.groups\n      continue unless value?\n      if key.startsWith @_metachr\n        token_tid           = key[ @_metachrlen .. ]\n        token_value         = value\n      else\n        key                 = ( key.split @_metachr )[ 1 ]\n        ( data ?= {} )[ key ]  = if value is '' then null else value\n    lexeme  = @registry[ @state.mode ].lexemes[ token_tid ]\n    token   = @_new_token token_tid, token_value, match[ 0 ].length, data, lexeme\n    return { token, lexeme, }\n\n  #---------------------------------------------------------------------------------------------------------\n  run: ( source_or_cfg ) -> [ ( @walk source_or_cfg )..., ]\n\n\n  #=========================================================================================================\n  # WALK\n  #---------------------------------------------------------------------------------------------------------\n  walk: ( source_or_cfg ) ->\n    cfg = @types.cast.ilx_walk_source_or_cfg source_or_cfg\n    # @set_offset cfg\n    yield @cfg.first if @cfg.first?\n    if cfg.source? then yield from @_walk_text        cfg\n    else                yield from @_walk_file_lines  cfg\n    yield @cfg.last if @cfg.last?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text: ( cfg ) ->\n    return @_walk_text_lines cfg if ( @cfg.split is 'lines' )\n    return @_walk_text_whole cfg\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text_whole: ( cfg ) ->\n    @feed cfg\n    #.......................................................................................................\n    loop\n      break if @state.finished\n      yield from @step()\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_text_lines: ( cfg ) ->\n    #.......................................................................................................\n    for { lnr: lnr1, line, eol, } from GUY.str.walk_lines_with_positions cfg.source, \\\n      { trim: @cfg.trim, prepend: @cfg.prepend, append: @cfg.append, }\n      yield @cfg.start_of_line if @cfg.start_of_line?\n      yield from @_walk_text_whole { cfg..., lnr1, source: line, eol, }\n      yield @cfg.end_of_line if @cfg.end_of_line?\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_file_lines: ( cfg ) ->\n    ### TAINT should provide `lnr1`, `eol` as well ###\n    ### TAINT derive `cfg` for line iterator (`trim`, `chunk_size`) ###\n    for { line, } from GUY.fs.walk_lines_with_positions cfg.path, \\\n      { trim: @cfg.trim, prepend: @cfg.prepend, append: @cfg.append, }\n      yield @cfg.start_of_line if @cfg.start_of_line?\n      yield from @_walk_text { cfg..., source: line, }\n      yield @cfg.end_of_line if @cfg.end_of_line?\n    return null\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  step: ->\n    R         = []\n    prv_mode  = @state.mode\n    token     = @_step()\n    #.......................................................................................................\n    if token?\n      R.push token\n      token_mode = get_token_mode token\n      if @cfg.border_tokens and ( ( @state.mode isnt prv_mode ) or ( token_mode isnt prv_mode ) )\n        if is_singleton_jump = ( @state.mode is prv_mode )\n          prv = prv_mode\n          nxt = @get_token_mode token\n        else\n          prv = prv_mode\n          nxt = @state.mode\n        border = @_new_token '$border', @cfg.border_value, 0, { prv, nxt, }\n        #...................................................................................................\n        if is_singleton_jump\n          R.unshift lets border, ( border ) ->\n            border.x1 = border.x2 = token.x1\n          R.push    lets border, ( border ) ->\n            border.x1 = border.x2 = border.x2\n            [ border.data.prv, border.data.nxt, ] = [ border.data.nxt, border.data.prv, ]\n        #...................................................................................................\n        else\n          if token_mode isnt prv_mode\n            R.unshift lets border, ( border ) -> border.x1 = border.x2 = token.x1\n          else if token_mode is prv_mode\n            R.push    lets border, ( border ) -> border.x1 = border.x2 = border.x2\n    #.......................................................................................................\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _step: ->\n    #.......................................................................................................\n    ### Affordance for lexemes matching only end-of-input (pattern `/$/y`): ###\n    if ( @state.prv_last_idx is @state.source.length ) and ( match = @state.source.match @state.pattern )?\n      ### TAINT code duplication ###\n      { token\n        lexeme          } = @_token_and_lexeme_from_match match\n      token               = @_get_next_token lexeme, token, match\n      @state.prv_last_idx = @state.pattern.lastIndex + 1\n      return token\n    #.......................................................................................................\n    if @state.prv_last_idx >= @state.source.length\n      ### reached end ###\n      @state.finished     = true\n      token               = @_new_token '$eof', '', 0 if @cfg.eof_token\n      return token\n    #.......................................................................................................\n    match = @state.source.match @state.pattern\n    #.......................................................................................................\n    unless match?\n      ### TAINT might want to advance and try again? ###\n      @state.finished  = true\n      token            = @_new_token '$error', '', 0, { code: 'nomatch', }\n      return token\n    #.......................................................................................................\n    if @state.pattern.lastIndex is @state.prv_last_idx\n      if match?\n        { token } = @_token_and_lexeme_from_match match\n        ### TAINT uses code units, should use codepoints ###\n        center    = token.x2\n        left      = Math.max 0, center - 11\n        right     = Math.min @state.source.length, center + 11\n        before    = @state.source[ left ... center ]\n        after     = @state.source[ center + 1 .. right ]\n        mid       = @state.source[ center ]\n        ### TAINT raise error or return error token ###\n        warn '^31-9^', { before, mid, after, }\n        warn '^31-10^', GUY.trm.reverse \"pattern #{rpr token.$key} matched empty string; stopping\"\n        @state.finished = true\n      else\n        ### TAINT raise error or return error token ###\n        warn '^31-11^', GUY.trm.reverse \"nothing matched; detected loop, stopping\"\n        @state.finished = true\n        return null\n    #.......................................................................................................\n    { token\n      lexeme          } = @_token_and_lexeme_from_match match\n    token               = @_get_next_token lexeme, token, match\n    @state.prv_last_idx = @state.pattern.lastIndex\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  _call_jump_handler: ( lexeme, token, match ) ->\n    unless ( divert = lexeme.jump { token, match, lexer: @, } )?\n      jump_cfg = GUY.props.pick_with_fallback lexeme, null, 'jump_time', 'jump_target'\n      return { token, jump_cfg..., jump_action: null, }\n    #.......................................................................................................\n    switch type = @types.type_of divert\n      when 'text'\n        return { token, ( @_parse_jump_cfg divert )..., }\n      when 'object'\n        token = divert.token ? token\n        if divert.jump?\n          jump_cfg = @_parse_jump_cfg divert.jump\n        else\n          jump_cfg = null\n        return { token, jump_cfg..., }\n    #.......................................................................................................\n    throw new E.Interlex_TBDUNCLASSIFIED '^interlex._call_jump_handler@1^', \\\n      \"jump handler of lexeme #{rpr lexeme.$key} returned illegal value #{rpr divert}\"\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_next_token: ( lexeme, token, match ) ->\n    ### TAINT code duplication ###\n    if lexeme.jump_action is 'callme'\n      { token\n        jump_action\n        jump_time\n        jump_target } = @_call_jump_handler lexeme, token, match\n      overrides       = { jump_action, jump_time, jump_target, }\n      ### ???\n      token = lets token, ( token ) => token.jump = if jump_action is 'nojump' then null else @state.mode\n      ###\n    else\n      { jump_action\n        jump_time\n        jump_target } = lexeme\n      overrides       = null\n    return token unless jump_action?\n    switch jump_action\n      when 'nojump'   then null\n      when 'pushpop'\n        token = @_push_mode  lexeme, token, overrides\n        token = @_pop_mode   lexeme, token, overrides\n      when 'pushmode' then token = @_push_mode  lexeme, token, overrides\n      when 'popmode'  then token = @_pop_mode   lexeme, token, overrides\n      else\n        throw new E.Interlex_internal_error '^interlex._get_next_token@2^', \\\n          \"unknown jump_action (#{rpr jump_action}) from lexeme #{rpr lexeme}\"\n    return token\n\n  #---------------------------------------------------------------------------------------------------------\n  _pop_mode: ( lexeme, token, overrides ) ->\n    unless @state.stack.length > 0\n      throw new E.Interlex_mode_stack_exhausted '^interlex._pop_mode@2^', \\\n        \"unable to jump back from initial state\"\n    { jump_time }             = overrides ? lexeme\n    @state.mode               = @state.stack.pop()\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return lets token, ( token ) =>\n      token.jump = @state.mode\n      if jump_time is 'exclusive'\n        _set_token_mode token, @state.mode\n      return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _push_mode: ( lexeme, token, overrides ) ->\n    { jump_target\n      jump_time   }           = overrides ? lexeme\n    @state.stack.push @state.mode\n    @state.mode               = jump_target\n    old_last_idx              = @state.pattern.lastIndex\n    @state.pattern            = @registry[ @state.mode ].pattern\n    @state.pattern.lastIndex  = old_last_idx\n    return lets token, ( token ) =>\n      token.jump = jump_target\n      if jump_time is 'inclusive'\n        _set_token_mode token, jump_target\n      return null\n\n\n  #=========================================================================================================\n  # CATCHALL & RESERVED\n  #---------------------------------------------------------------------------------------------------------\n  _add_reserved_chrs: ( mode, reserved_chrs ) ->\n    unless ( entry = @registry[ mode ] )?\n      throw new E.Interlex_internal_error '^interlex._add_reserved_chrs@1^', \"no such mode: #{rpr mode}\"\n    if @types.isa.list reserved_chrs\n      @_add_reserved_chrs mode, x for x in reserved_chrs\n      return null\n    ### NOTE may accept regexes in the future ###\n    @types.validate.nonempty.text reserved_chrs\n    entry.reserved_chrs.add reserved_chrs\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _get_catchall_regex: ( mode, entry ) -> compose.charSet.complement @_get_reserved_regex mode, entry\n  _get_reserved_regex: ( mode, entry ) -> compose.either entry.reserved_chrs...\n\n  #---------------------------------------------------------------------------------------------------------\n  _add_catchall_lexeme: ( mode, lxid, entry ) ->\n    pattern = @_get_catchall_regex mode, entry\n    pattern = compose.suffix '+', pattern if entry.catchall.concat\n    @add_lexeme { mode, lxid, pattern, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _add_reserved_lexeme: ( mode, lxid, entry ) ->\n    pattern = @_get_reserved_regex mode, entry\n    pattern = compose.suffix '+', pattern if entry.reserved.concat\n    @add_lexeme { mode, lxid, pattern, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  add_catchall_lexeme: ( cfg ) ->\n    cfg       = @types.create.ilx_add_catchall_lexeme_cfg cfg\n    cfg.mode ?= @base_mode\n    unless ( entry = @registry[ cfg.mode ] )?\n      throw new E.Interlex_mode_unknown '^interlex.add_catchall_lexeme@1^', cfg.mode\n    if entry.catchall?\n      throw new E.Interlex_catchall_exists '^interlex.add_catchall_lexeme@1^', cfg.mode, entry.catchall.lxid\n    entry.catchall = cfg\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  add_reserved_lexeme: ( cfg ) ->\n    cfg       = @types.create.ilx_add_reserved_lexeme_cfg cfg\n    cfg.mode ?= @base_mode\n    unless ( entry = @registry[ cfg.mode ] )?\n      throw new E.Interlex_mode_unknown '^interlex.add_reserved_lexeme@1^', cfg.mode\n    if entry.reserved?\n      throw new E.Interlex_reserved_exists '^interlex.add_reserved_lexeme@1^', cfg.mode, entry.reserved.lxid\n    entry.reserved = cfg\n    return null\n\n\n  #=========================================================================================================\n  # GETTING AND SETTING TOKEN $KEY PARTS\n  #---------------------------------------------------------------------------------------------------------\n  get_token_lxid:   get_token_lxid\n  @get_token_lxid:  get_token_lxid\n\n  #---------------------------------------------------------------------------------------------------------\n  get_token_mode:   get_token_mode\n  @get_token_mode:  get_token_mode\n\n  #---------------------------------------------------------------------------------------------------------\n  set_token_mode:   set_token_mode\n  @set_token_mode:  set_token_mode\n\n\n  #=========================================================================================================\n  # POSITIONING API\n  #---------------------------------------------------------------------------------------------------------\n  set_position: ( cfg ) ->\n    cfg               = @types.create.ilx_set_position_cfg cfg\n    @state.lnr1       = cfg.lnr1 - 1  if cfg.lnr1?\n    @state.posapi_x1  = cfg.x1        if cfg.x1?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  get_token_position:   ( token ) -> GUY.props.pick_with_fallback token, null, 'lnr1', 'x1', 'lnr2', 'x2'\n  @get_token_position:  ( token ) -> GUY.props.pick_with_fallback token, null, 'lnr1', 'x1', 'lnr2', 'x2'\n\n#===========================================================================================================\nmodule.exports = { Interlex, compose, sorter, }\n\n"
  ]
}