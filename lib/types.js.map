{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/types.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n# { alert\n#   debug\n#   help\n#   info\n#   plain\n#   praise\n#   urge\n#   warn\n#   whisper }               = GUY.trm.get_loggers 'DATAMILL/TYPES'\n{ debug }                 = GUY.trm.get_loggers 'INTERTEXT-LEXER/TYPES'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n{ Intertype }             = require 'intertype'\nbase_types                = null\nmisfit                    = Symbol 'misfit'\njump_symbol               = '^'\n# PATH                      = require 'node:path'\n\n\n#-----------------------------------------------------------------------------------------------------------\nget_base_types = ->\n  return base_types if base_types?\n  #.........................................................................................................\n  base_types                = new Intertype()\n  { declare }               = base_types\n  #.........................................................................................................\n  # declare.ilx_pattern     override: true, isa: ( x ) -> x instanceof Document\n  declare.syntax_target 'list.or.object'\n  ### TAINT legal mode names, lexeme IDs should be confined to JS identifiers ###\n  ### TAINT legal mode names should exclude `lx`, `new` to avoid name clashes ###\n  declare.ilx_mode            'nonempty.text'\n  declare.ilx_tid             'nonempty.text'\n  declare.ilx_pattern         'text.or.regex'\n  declare.ilx_pop             ( x ) -> x is jump_symbol\n  declare.ilx_jump            'ilx_mode.or.ilx_pop.or.function'\n  declare.ilx_reserved        'optional.ilx_reserved_list.or.ilx_reserved_text'\n  declare.ilx_reserved_list   'list.of.nonempty.text'\n  declare.ilx_reserved_text   'nonempty.text'\n  #.........................................................................................................\n  declare.ilx_add_lexeme_cfg\n    fields:\n      mode:           'ilx_mode'\n      tid:            'ilx_tid'\n      pattern:        'ilx_pattern'\n      jump:           'optional.ilx_jump'\n      reserved:       'optional.ilx_reserved'\n      create:         'optional.function'\n    default:\n      mode:           'plain'\n      tid:            null\n      pattern:        null\n      jump:           null\n      reserved:       null\n      create:         null\n  #.........................................................................................................\n  declare.ilx_constructor_cfg\n    fields:\n      autostart:        'boolean'\n      start_token:      'boolean'\n      end_token:        'boolean'\n      error_tokens:     'boolean'\n      multiline:        'boolean'\n      dotall:           'boolean'\n      catchall_concat:  'boolean'\n      reserved_concat:  'boolean'\n      linewise:         'boolean'\n      lnr:              'positive1.integer'\n      offset:           'positive0.integer'\n      trim:             'boolean'\n      # global ???\n      # ignorecase  # ignoreCase\n    default:\n      autostart:        true\n      start_token:      false\n      end_token:        false\n      error_tokens:     true\n      multiline:        false\n      dotall:           false\n      catchall_concat:  false\n      reserved_concat:  false\n      linewise:         false\n      lnr:              1\n      offset:           0\n      trim:             true\n  #.........................................................................................................\n  declare.ilx_walk_source_or_cfg\n    fields:\n      source:           'optional.text'\n      path:             'optional.nonempty.text'\n      _error:           'null'\n    default:\n      source:           null\n      path:             null\n      _error:           null\n    cast: ( x ) ->\n      return { @registry.ilx_walk_source_or_cfg.default..., source: x, } if @isa.text x\n      return x unless @isa.object x\n      R = { @registry.ilx_walk_source_or_cfg.default..., x..., }\n      if ( not x.source? and not x.path? )\n        R._error = \"must set either `source` or `path`\"\n      if ( x.source? and x.path? )\n        R._error = \"cannot set both `source` and `path`\"\n      return R\n  #.........................................................................................................\n  declare.ilx_add_catchall_lexeme_cfg\n    fields:\n      mode:           'ilx_mode'\n      tid:            'ilx_tid'\n    default:\n      mode:           null\n      tid:            '$catchall'\n  declare.ilx_add_reserved_lexeme_cfg\n    fields:\n      mode:           'ilx_mode'\n      tid:            'ilx_tid'\n    default:\n      mode:           null\n      tid:            '$reserved'\n  return base_types\n\n\n#===========================================================================================================\nmodule.exports = { misfit, jump_symbol, get_base_types, }\n\n\n\n"
  ]
}