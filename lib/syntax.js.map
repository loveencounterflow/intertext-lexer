{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/syntax.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER/SYNTAX'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n{ get_base_types }        = require './types'\nE                         = require './errors'\n\n\n#===========================================================================================================\n#\n#===========================================================================================================\nclass Syntax\n\n  ###\n  * lexemes to be declared as *static* members (i.e. as class attributes) will be compiled\n  * lexeme factories that need additional parameters should use the prefix `new_` and be put on the\n    instance\n  * lexeme factories that are defined on the class will be called with the implicit `this`/`@` being the\n    *instance*, not the class\n\n  * specials:\n    `@mode` indicates the (name of the) (base) mode; this can be overridden at instantiation time\n    `@mode_*` indicate the (names of the) other modes; these can be overridden at instantiation time\n\n  * use prefix `@lx_*` for string, regex, object, or a list thereof; alternatively a function returning one\n    of the aforementioned\n  * use prefix `new_*` for lexeme-factories that need additional parameters\n\n  * TID (the lexeme's name) will default to the part after the prefix\n\n  ```coffee\n  class ClassWithStaticMethod\n    @staticProperty: 'someValue'\n    @staticMethod: () ->\n      return 'static method has been called.'\n  ```\n\n  ```js\n  class ClassWithStaticMethod {\n    static staticProperty = 'someValue';\n    static staticMethod() {\n      return 'static method has been called.'; } }\n  ```\n\n  ###\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    GUY.props.hide @, 'types', get_base_types()\n    ### TAINT allow renaming of lexemes ###\n    mode                  = @constructor.mode ? 'std'\n    ### TAINT use types ###\n    @cfg                  = { mode, cfg..., }\n    #.......................................................................................................\n    ### TAINT make configurable ###\n    @cfg.prefix           = 'lx_'\n    @cfg.import_prefix    = @cfg.prefix\n    @cfg.export_prefix    = @cfg.prefix\n    @cfg._import_matcher  = /^lx_(?<tid>.+)$/\n    #.......................................................................................................\n    @_lexeme_default      = { @types.registry.ilx_add_lexeme_cfg.default..., }\n    lexeme_keys           = new Set Object.keys @_lexeme_default\n    @_lexeme_default[ k ] = v for k, v of @cfg when lexeme_keys.has k\n    # @_compile_lexemes { target: @, }\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  add_lexemes: ( target = null ) ->\n    target ?= @\n    @types.validate.syntax_target target\n    @_compile_lexemes { target, }\n    return null\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  _compile_list_of_lexemes: ( tid, list_of_lexemes ) ->\n    return ( ( @_compile_lexeme ( \"#{tid}_#{idx + 1}\" ), lexeme ) for lexeme, idx in list_of_lexemes )\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_lexeme: ( tid, lexeme ) ->\n    lexeme  = { tid, pattern: lexeme, } if @types.isa.ilx_pattern lexeme\n    lexeme  = { @_lexeme_default..., lexeme..., } if @types.isa.object lexeme\n    @types.validate.ilx_add_lexeme_cfg lexeme\n    return lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_lexemes: ({ target, }) ->\n    target       ?= @\n    use_push      = @types.isa.list target\n    #.......................................................................................................\n    for xtid in Object.getOwnPropertyNames @constructor\n      continue unless ( match = xtid.match @cfg._import_matcher )?\n      { tid, }      = match.groups\n      lexeme        = @constructor[ xtid ]\n      lx_type       = @types.type_of lexeme\n      #.....................................................................................................\n      if lx_type is 'function'\n        lexeme        = lexeme.call @\n        lx_type       = @types.type_of lexeme\n      ### TAINT validate proto-lexeme ###\n      #.....................................................................................................\n      if lx_type is 'list' then lexeme = @_compile_list_of_lexemes tid, lexeme\n      else                      lexeme = @_compile_lexeme tid, lexeme\n      #.....................................................................................................\n      if use_push\n        if lx_type is 'list' then ( target.push lx for lx in lexeme )\n        else                      ( target.push lexeme )\n      #.....................................................................................................\n      else\n        if lx_type is 'list' then ( target[ \"#{lx.mode}_#{lx.tid}\" ] = lx for lx in lexeme )\n        else                      ( target[ \"#{lexeme.mode}_#{lexeme.tid}\" ] = lexeme )\n    #.......................................................................................................\n    return null\n\n\n#===========================================================================================================\nmodule.exports = { Syntax, }\n\n\n\n\n"
  ]
}