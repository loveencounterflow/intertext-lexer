{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/syntax.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER/SYNTAX'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n{ get_base_types }        = require './types'\n\n#===========================================================================================================\n#\n#===========================================================================================================\nclass Syntax\n\n  ###\n  * lexemes declared as *static* members (i.e. as class attributes) will be compiled\n  * lexemes declared as *instance* members will be left as-is\n  * use prefix\n    `@lx_*` for string, regex, or object\n    `@lxs_*` for list of objects\n    `@get_lx_*()` for function that returns an object\n    `@get_lxs_*()` for function that returns list of objects\n  * TID (the lexeme's name) will default to the part after the prefix\n\n  ```coffee\n  class ClassWithStaticMethod\n    @staticProperty: 'someValue'\n    @staticMethod: () ->\n      return 'static method has been called.'\n  ```\n\n  ```js\n  class ClassWithStaticMethod {\n    static staticProperty = 'someValue';\n    static staticMethod() {\n      return 'static method has been called.'; } }\n  ```\n\n  ###\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    GUY.props.hide @, 'types', get_base_types()\n    ### TAINT must separate `cfg` items for the instance from defaults for the lexeme ###\n    @cfg                  = { mode: 'std', cfg..., }\n    @_lexeme_default      = { @types.registry.ilx_add_lexeme_cfg.default..., }\n    lexeme_keys           = new Set Object.keys @_lexeme_default\n    @_lexeme_default[ k ] = v for k, v of @cfg when lexeme_keys.has k\n    @_compile_lexemes()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_list_of_lexemes: ( tid, list_of_lexemes ) ->\n    return ( ( @_compile_lexeme ( \"#{tid}_#{idx + 1}\" ), lexeme ) for lexeme, idx in list_of_lexemes )\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_lexeme: ( tid, lexeme ) ->\n    lexeme  = { tid, pattern: lexeme, } if @types.isa.ilx_pattern lexeme\n    lexeme  = { @_lexeme_default..., lexeme..., } if @types.isa.object lexeme\n    @types.validate.ilx_add_lexeme_cfg lexeme\n    return lexeme\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_lexemes: ->\n    for xtid in Object.getOwnPropertyNames @constructor\n      continue unless ( match = xtid.match /^(?<get>get_|)(?<number>lxs?_)(?<tid>.+)$/ )?\n      { get, number, tid, } = match.groups\n      is_function           = get isnt ''\n      number                = if number is 'lx_' then 'singular' else 'plural'\n      lexeme                = @constructor[ xtid ]\n      lx_type               = @types.type_of lexeme\n      urge '^324^', { xtid, tid, number, lexeme, }\n      try\n        if is_function\n          null\n        else\n          if number is 'singular'\n            if lx_type is 'list'\n              throw new Error \"^238947^ must use prefix 'lxs_' for list of lexemes; got #{rpr xtid}\"\n            lexeme = @_compile_lexeme tid, lexeme\n          else\n            lexeme = @_compile_list_of_lexemes tid, lexeme\n      catch error\n        throw error unless error.constructor.name is 'Intertype_validation_error'\n        # error.message\n        throw error\n      debug '^2124^', lexeme\n      # #.....................................................................................................\n      # switch type = @types.type_of lexeme\n      #   when 'object' then @[ tid ] = { @cfg..., lexeme..., }\n      #   when 'list'   then @[ tid ] = ( { @cfg..., lx..., } for lx in lexeme )\n      #   #...................................................................................................\n      #   when 'function'\n      #     lexeme = lexeme.call @\n      #     switch subtype = type_of lexeme\n      #       when 'object' then  @[ tid ] = lexeme ### NOTE lexemes returned by functions should be complete ###\n      #       when 'list'   then  @[ tid ] = lexeme ### NOTE lexemes returned by functions should be complete ###\n      #       else throw new Error \"^849687388^ expected an object or a list of objects, found a #{type}\"\n      #   #...................................................................................................\n      #   else throw new Error \"^849687349^ expected an object or a function, found a #{type}\"\n    return null\n\n\n#===========================================================================================================\nmodule.exports = { Syntax, }\n\n\n\n\n"
  ]
}